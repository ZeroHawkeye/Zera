---
title: API Development
description: Learn how to develop APIs using the Zera framework
---

Zera uses Protocol Buffers to define APIs and serves them via Connect-RPC.

Create your proto file under the `proto/` directory:

```proto
// proto/user/v1/user.proto
syntax = "proto3";

package user.v1;

import "buf/validate/validate.proto";

// 用户服务
service UserService {
  // 获取用户信息
  rpc GetUser(GetUserRequest) returns (GetUserResponse);
  
  // 创建用户
  rpc CreateUser(CreateUserRequest) returns (CreateUserResponse);
}

message GetUserRequest {
  string id = 1 [(buf.validate.field).string.min_len = 1];
}

message GetUserResponse {
  User user = 1;
}

message CreateUserRequest {
  string name = 1 [(buf.validate.field).string.min_len = 1];
  string email = 2 [(buf.validate.field).string.email = true];
}

message CreateUserResponse {
  User user = 1;
}

message User {
  string id = 1;
  string name = 2;
  string email = 3;
  int64 created_at = 4;
}
```

// proto/user/v1/user.proto

```bash
task proto:gen
```

This will generate corresponding code in the `backend/gen/` and `frontend/src/gen/` directories.

Create handlers in the `backend/internal/handler/` directory:

```go
// backend/internal/handler/user.go
package handler

import (
	"context"
	
	"connectrpc.com/connect"
	userv1 "your-project/gen/user/v1"
)

type UserHandler struct {
	// 依赖注入
}

func NewUserHandler() *UserHandler {
	return &UserHandler{}
}

func (h *UserHandler) GetUser(
	ctx context.Context,
	req *connect.Request[userv1.GetUserRequest],
) (*connect.Response[userv1.GetUserResponse], error) {
	// 实现业务逻辑
	user := &userv1.User{
		Id:    req.Msg.Id,
		Name:  "示例用户",
		Email: "user@example.com",
	}
	
	return connect.NewResponse(&userv1.GetUserResponse{
		User: user,
	}), nil
}

func (h *UserHandler) CreateUser(
	ctx context.Context,
	req *connect.Request[userv1.CreateUserRequest],
) (*connect.Response[userv1.CreateUserResponse], error) {
	// 实现创建逻辑
	user := &userv1.User{
		Id:    "generated-id",
		Name:  req.Msg.Name,
		Email: req.Msg.Email,
	}
	
	return connect.NewResponse(&userv1.CreateUserResponse{
		User: user,
	}), nil
}
```

Register handlers when the server starts:

```go
// backend/internal/server/server.go
import (
	"your-project/gen/user/v1/userv1connect"
	"your-project/internal/handler"
)

func SetupRoutes(mux *http.ServeMux) {
	userHandler := handler.NewUserHandler()
	path, h := userv1connect.NewUserServiceHandler(userHandler)
	mux.Handle(path, h)
}
```

---
title: Quick Start
description: Learn how to use the framework
---

## Installation

Install dependencies using the following command:

```bash
npm install example
```

### Configuration File

Add configuration in `config.ts`:

```typescript
export const config = {
  name: "example"
};
```

<Callout type="info">
  This is a tip message.
</Callout>

```typescript
// frontend/src/config/index.ts
import { createClient } from "@connectrpc/connect";
import { createConnectTransport } from "@connectrpc/connect-web";
import { UserService } from "../gen/user/v1/user_pb";

const transport = createConnectTransport({
  baseUrl: "http://localhost:8080",
});

export const userClient = createClient(UserService, transport);
```

// frontend/src/config/index.ts

```tsx
// frontend/src/components/UserProfile.tsx
import { useEffect, useState } from "react";
import { userClient } from "../config";
import type { User } from "../gen/user/v1/user_pb";

export function UserProfile({ userId }: { userId: string }) {
  const [user, setUser] = useState<User | null>(null);

  useEffect(() => {
    async function fetchUser() {
      const response = await userClient.getUser({ id: userId });
      setUser(response.user);
    }
    fetchUser();
  }, [userId]);

  if (!user) return <div>Loading...</div>;

  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  );
}
```

Zera uses [buf/validate](https://github.com/bufbuild/protovalidate) for request validation:

```proto
import "buf/validate/validate.proto";

message CreateUserRequest {
  // 名称必须非空
  string name = 1 [(buf.validate.field).string.min_len = 1];
  
  // 邮箱必须是有效格式
  string email = 2 [(buf.validate.field).string.email = true];
  
  // 年龄必须在 0-150 之间
  int32 age = 3 [(buf.validate.field).int32 = {gte: 0, lte: 150}];
}
```

Connect-RPC provides a standard error handling mechanism:

```go
import "connectrpc.com/connect"

func (h *UserHandler) GetUser(
	ctx context.Context,
	req *connect.Request[userv1.GetUserRequest],
) (*connect.Response[userv1.GetUserResponse], error) {
	user, err := h.service.FindUser(ctx, req.Msg.Id)
	if err != nil {
		if errors.Is(err, ErrNotFound) {
			return nil, connect.NewError(
				connect.CodeNotFound,
				fmt.Errorf("用户不存在: %s", req.Msg.Id),
			)
		}
		return nil, connect.NewError(
			connect.CodeInternal,
			err,
		)
	}
	
	return connect.NewResponse(&userv1.GetUserResponse{
		User: user,
	}), nil
}
```

Frontend error handling:

```typescript
import { ConnectError, Code } from "@connectrpc/connect";

try {
  const response = await userClient.getUser({ id: userId });
} catch (err) {
  if (err instanceof ConnectError) {
    if (err.code === Code.NotFound) {
      console.log("用户不存在");
    }
  }
}
```