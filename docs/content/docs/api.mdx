---
title: API 开发
description: 学习如何使用 Zera 框架开发 API
---

Zera 使用 Protocol Buffers 定义 API，并通过 Connect-RPC 提供服务。

## 定义 API

### 1. 创建 Proto 文件

在 `proto/` 目录下创建你的 proto 文件：

```proto
// proto/user/v1/user.proto
syntax = "proto3";

package user.v1;

import "buf/validate/validate.proto";

// 用户服务
service UserService {
  // 获取用户信息
  rpc GetUser(GetUserRequest) returns (GetUserResponse);
  
  // 创建用户
  rpc CreateUser(CreateUserRequest) returns (CreateUserResponse);
}

message GetUserRequest {
  string id = 1 [(buf.validate.field).string.min_len = 1];
}

message GetUserResponse {
  User user = 1;
}

message CreateUserRequest {
  string name = 1 [(buf.validate.field).string.min_len = 1];
  string email = 2 [(buf.validate.field).string.email = true];
}

message CreateUserResponse {
  User user = 1;
}

message User {
  string id = 1;
  string name = 2;
  string email = 3;
  int64 created_at = 4;
}
```

### 2. 生成代码

```bash
task proto:gen
```

这会在 `backend/gen/` 和 `frontend/src/gen/` 目录下生成对应的代码。

## 实现后端服务

### 1. 创建 Handler

在 `backend/internal/handler/` 目录下创建处理器：

```go
// backend/internal/handler/user.go
package handler

import (
	"context"
	
	"connectrpc.com/connect"
	userv1 "your-project/gen/user/v1"
)

type UserHandler struct {
	// 依赖注入
}

func NewUserHandler() *UserHandler {
	return &UserHandler{}
}

func (h *UserHandler) GetUser(
	ctx context.Context,
	req *connect.Request[userv1.GetUserRequest],
) (*connect.Response[userv1.GetUserResponse], error) {
	// 实现业务逻辑
	user := &userv1.User{
		Id:    req.Msg.Id,
		Name:  "示例用户",
		Email: "user@example.com",
	}
	
	return connect.NewResponse(&userv1.GetUserResponse{
		User: user,
	}), nil
}

func (h *UserHandler) CreateUser(
	ctx context.Context,
	req *connect.Request[userv1.CreateUserRequest],
) (*connect.Response[userv1.CreateUserResponse], error) {
	// 实现创建逻辑
	user := &userv1.User{
		Id:    "generated-id",
		Name:  req.Msg.Name,
		Email: req.Msg.Email,
	}
	
	return connect.NewResponse(&userv1.CreateUserResponse{
		User: user,
	}), nil
}
```

### 2. 注册服务

在服务器启动时注册处理器：

```go
// backend/internal/server/server.go
import (
	"your-project/gen/user/v1/userv1connect"
	"your-project/internal/handler"
)

func SetupRoutes(mux *http.ServeMux) {
	userHandler := handler.NewUserHandler()
	path, h := userv1connect.NewUserServiceHandler(userHandler)
	mux.Handle(path, h)
}
```

## 前端调用

### 1. 创建客户端

```typescript
// frontend/src/config/index.ts
import { createClient } from "@connectrpc/connect";
import { createConnectTransport } from "@connectrpc/connect-web";
import { UserService } from "../gen/user/v1/user_pb";

const transport = createConnectTransport({
  baseUrl: "http://localhost:8080",
});

export const userClient = createClient(UserService, transport);
```

### 2. 调用 API

```tsx
// frontend/src/components/UserProfile.tsx
import { useEffect, useState } from "react";
import { userClient } from "../config";
import type { User } from "../gen/user/v1/user_pb";

export function UserProfile({ userId }: { userId: string }) {
  const [user, setUser] = useState<User | null>(null);

  useEffect(() => {
    async function fetchUser() {
      const response = await userClient.getUser({ id: userId });
      setUser(response.user);
    }
    fetchUser();
  }, [userId]);

  if (!user) return <div>Loading...</div>;

  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  );
}
```

## 请求验证

Zera 使用 [buf/validate](https://github.com/bufbuild/protovalidate) 进行请求验证：

```proto
import "buf/validate/validate.proto";

message CreateUserRequest {
  // 名称必须非空
  string name = 1 [(buf.validate.field).string.min_len = 1];
  
  // 邮箱必须是有效格式
  string email = 2 [(buf.validate.field).string.email = true];
  
  // 年龄必须在 0-150 之间
  int32 age = 3 [(buf.validate.field).int32 = {gte: 0, lte: 150}];
}
```

## 错误处理

Connect-RPC 提供了标准的错误处理机制：

```go
import "connectrpc.com/connect"

func (h *UserHandler) GetUser(
	ctx context.Context,
	req *connect.Request[userv1.GetUserRequest],
) (*connect.Response[userv1.GetUserResponse], error) {
	user, err := h.service.FindUser(ctx, req.Msg.Id)
	if err != nil {
		if errors.Is(err, ErrNotFound) {
			return nil, connect.NewError(
				connect.CodeNotFound,
				fmt.Errorf("用户不存在: %s", req.Msg.Id),
			)
		}
		return nil, connect.NewError(
			connect.CodeInternal,
			err,
		)
	}
	
	return connect.NewResponse(&userv1.GetUserResponse{
		User: user,
	}), nil
}
```

前端处理错误：

```typescript
import { ConnectError, Code } from "@connectrpc/connect";

try {
  const response = await userClient.getUser({ id: userId });
} catch (err) {
  if (err instanceof ConnectError) {
    if (err.code === Code.NotFound) {
      console.log("用户不存在");
    }
  }
}
```
